
package ${model.package};

import java.sql.SQLException;
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import org.bridje.ioc.Ioc;
import org.bridje.ioc.Inject;
import org.bridje.sql.*;
import org.bridje.orm.*;
import javax.annotation.Generated;

/**
 * This class represents the ${model.name} data model.
 * it must be use to read and write ${model.name} entities.
 * The full list of ${model.name} entities is the following.
 * <ul>
<#list model.entities as entity >
 * <li>${entity.name}<br></li>
</#list>
 * </ul>
 */
@Generated(value = "org.bridje.orm.srcgen.OrmSourceGenerator", date = "${.now?string("yyyy-MM-dd")}", comments = "Generated by Bridje ORM API")
public class ${model.name}
{
    public static final Schema SCHEMA;

    public static final Query[] QUERIES;

    static {
        SCHEMA = SQL.buildSchema("${model.schema}")
                    <#list model.entities as entity>
                    .table(${entity.name}.TABLE)
                    </#list>
                    .build();

        QUERIES = new Query[]
        {
            
        };
    }

    @Inject
    private EntityContext ctx;

    @Inject
    private SQLEnvironment env;

    public void fixSchema() throws SQLException
    {
        env.fixSchema(SCHEMA);
    }

    <#list model.entities as entity>
    ${entity.name} parse${entity.name}(SQLResultSet rs) throws SQLException
    {
        ${entity.name} entity = new ${entity.name}();
        parse${entity.name}(entity, rs);
        return entity;
    }

    void parse${entity.name}(${entity.name} entity, SQLResultSet rs) throws SQLException
    {
        <#list entity.allFields as field>
        entity.set${field.name?cap_first}(rs.get(${entity.name}.${field.column?upper_case}));
        </#list>
    }

    public ${entity.name} find${entity.name}(${entity.key.type.javaType} key) throws SQLException
    {
        return env.fetchOne(${entity.name}.FIND_QUERY, this::parse${entity.name}, key);
    }

    public void insert${entity.name}(${entity.name} entity) throws SQLException
    {
        <#if entity.key.autoIncrement>
        entity.set${entity.key.name?cap_first}(env.fetchOne(${entity.name}.INSERT_QUERY, (rs) -> rs.get(${entity.name}.${entity.key.column?upper_case}), <#list entity.nonAiFields as field>entity.get${field.name?cap_first}()<#sep>, </#sep></#list>));
        <#else>
        env.update(${entity.name}.INSERT_QUERY, <#list entity.nonAiFields as field>entity.get${field.name?cap_first}()<#sep>, </#sep></#list>);
        </#if>
    }

    public void update${entity.name}(${entity.name} entity) throws SQLException
    {
        update${entity.name}(entity, entity.get${entity.key.name?cap_first}());
    }

    public void update${entity.name}(${entity.name} entity, ${entity.key.type.javaType} key) throws SQLException
    {
        env.update(${entity.name}.UPDATE_QUERY, <#list entity.nonAiFields as field>entity.get${field.name?cap_first}()<#sep>, </#sep></#list>, key);
    }

    public void delete${entity.name}(${entity.name} entity) throws SQLException
    {
        delete${entity.name}(entity.get${entity.key.name?cap_first}());
    }

    public void delete${entity.name}(${entity.key.type.javaType} key) throws SQLException
    {
        env.update(${entity.name}.DELETE_QUERY, key);
    }

    </#list>
}
